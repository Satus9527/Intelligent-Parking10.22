# 核心功能开发实施手册

## 一、后端基础接口开发（步骤1）

### 1.1 用户管理接口

#### 1.1.1 数据模型
```java
// 用户实体类
@Data
@TableName("sys_user")
public class UserEntity {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    @NotBlank(message = "微信openid不能为空")
    private String openid;
    
    @TableField(fill = FieldFill.INSERT)
    private LocalDateTime createTime;
    
    @TableField(fill = FieldFill.INSERT_UPDATE)
    private LocalDateTime updateTime;
    
    private String nickname;
    private String avatar;
    private String phone;
    private Integer status; // 0-正常 1-禁用
}

// 用户DTO
@Data
public class UserDTO {
    private Long id;
    private String nickname;
    private String avatar;
    private String phone;
}
```

#### 1.1.2 接口实现
```java
@RestController
@RequestMapping("/api/v1/users")
public class UserController {
    @Autowired
    private UserService userService;
    
    @GetMapping("/{id}")
    @PreAuthorize("hasRole('USER') or @authService.isOwner(#id)")
    public ResultDTO<UserDTO> getUserById(@PathVariable Long id) {
        UserDTO user = userService.getUserById(id);
        return ResultDTO.success(user);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("@authService.isOwner(#id)")
    public ResultDTO<UserDTO> updateUser(
            @PathVariable Long id, 
            @Valid @RequestBody UserUpdateDTO userDTO) {
        UserDTO updated = userService.updateUser(id, userDTO);
        return ResultDTO.success(updated);
    }
    
    @GetMapping("/profile")
    @PreAuthorize("hasRole('USER')")
    public ResultDTO<UserDTO> getCurrentUserProfile() {
        UserDTO user = userService.getCurrentUserProfile();
        return ResultDTO.success(user);
    }
}
```

#### 1.1.3 权限控制实现
```java
@Service
public class AuthService {
    @Autowired
    private UserService userService;
    
    // 验证当前用户是否为资源所有者
    public boolean isOwner(Long resourceUserId) {
        Long currentUserId = SecurityUtils.getCurrentUserId();
        return currentUserId.equals(resourceUserId);
    }
    
    // 验证用户是否有管理员权限
    public boolean hasAdminRole() {
        return SecurityUtils.hasRole("ADMIN");
    }
}
```

### 1.2 车位管理接口

#### 1.2.1 核心API实现
```java
@RestController
@RequestMapping("/api/v1/parking-spaces")
public class ParkingSpaceController {
    @Autowired
    private ParkingSpaceService parkingSpaceService;
    
    @GetMapping
    public ResultDTO<PageInfo<ParkingSpaceDTO>> getParkingSpaces(
            @RequestParam(required = false) Integer status,
            @RequestParam(required = false) Integer type,
            @RequestParam(defaultValue = "1") Integer pageNum,
            @RequestParam(defaultValue = "10") Integer pageSize) {
        
        PageInfo<ParkingSpaceDTO> pageInfo = parkingSpaceService.findParkingSpaces(
                status, type, pageNum, pageSize);
        return ResultDTO.success(pageInfo);
    }
    
    @GetMapping("/{id}")
    public ResultDTO<ParkingSpaceDTO> getParkingSpaceDetail(@PathVariable Long id) {
        ParkingSpaceDTO space = parkingSpaceService.findById(id);
        return ResultDTO.success(space);
    }
    
    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public ResultDTO<ParkingSpaceDTO> createParkingSpace(
            @Valid @RequestBody ParkingSpaceCreateDTO createDTO) {
        ParkingSpaceDTO space = parkingSpaceService.createParkingSpace(createDTO);
        return ResultDTO.success(space);
    }
    
    @PutMapping("/{id}")
    @PreAuthorize("hasRole('ADMIN')")
    public ResultDTO<ParkingSpaceDTO> updateParkingSpace(
            @PathVariable Long id,
            @Valid @RequestBody ParkingSpaceUpdateDTO updateDTO) {
        ParkingSpaceDTO space = parkingSpaceService.updateParkingSpace(id, updateDTO);
        return ResultDTO.success(space);
    }
}
```

#### 1.2.2 数据访问层实现
```java
@Service
public class ParkingSpaceServiceImpl implements ParkingSpaceService {
    @Autowired
    private ParkingSpaceMapper parkingSpaceMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public PageInfo<ParkingSpaceDTO> findParkingSpaces(Integer status, Integer type, 
                                                     Integer pageNum, Integer pageSize) {
        PageHelper.startPage(pageNum, pageSize);
        List<ParkingSpaceEntity> entities = parkingSpaceMapper.selectByCondition(status, type);
        List<ParkingSpaceDTO> dtos = entities.stream()
                .map(this::convertToDTO)
                .collect(Collectors.toList());
        
        return new PageInfo<>(dtos);
    }
    
    @Override
    @Cacheable(value = "parking_space", key = "#id")
    public ParkingSpaceDTO findById(Long id) {
        ParkingSpaceEntity entity = parkingSpaceMapper.selectById(id);
        if (entity == null) {
            throw new BusinessException(ErrorEnum.PARKING_SPACE_NOT_FOUND);
        }
        return convertToDTO(entity);
    }
    
    // 其他方法实现...
}
```

### 1.3 预约管理接口

#### 1.3.1 接口定义与实现
```java
@RestController
@RequestMapping("/api/v1/reservations")
public class ReservationController {
    @Autowired
    private ReservationService reservationService;
    
    @PostMapping
    @PreAuthorize("hasRole('USER')")
    public ResultDTO<ReservationDTO> createReservation(
            @Valid @RequestBody ReservationCreateDTO createDTO) {
        ReservationDTO reservation = reservationService.createReservation(createDTO);
        return ResultDTO.success(reservation);
    }
    
    @GetMapping("/{id}")
    public ResultDTO<ReservationDTO> getReservationDetail(@PathVariable Long id) {
        ReservationDTO reservation = reservationService.findById(id);
        return ResultDTO.success(reservation);
    }
    
    @GetMapping("/current")
    @PreAuthorize("hasRole('USER')")
    public ResultDTO<ReservationDTO> getCurrentReservation() {
        ReservationDTO reservation = reservationService.getCurrentUserActiveReservation();
        return ResultDTO.success(reservation);
    }
    
    @PutMapping("/{id}/cancel")
    @PreAuthorize("hasRole('USER')")
    public ResultDTO<Void> cancelReservation(@PathVariable Long id) {
        reservationService.cancelReservation(id);
        return ResultDTO.success();
    }
}
```

## 二、小程序静态页面开发（步骤2）

### 2.1 首页设计与实现

#### 2.1.1 页面结构（index.vue）
```vue
<template>
  <view class="home-page">
    <!-- 顶部搜索栏 -->
    <view class="search-bar">
      <van-search
        v-model="searchValue"
        placeholder="搜索车位或停车场"
        @search="onSearch"
        background="#1677FF"
        shape="round"
      />
    </view>
    
    <!-- 轮播图 -->
    <van-swipe :autoplay="3000" indicator-color="white">
      <van-swipe-item v-for="(item, index) in banners" :key="index">
        <image :src="item.imageUrl" mode="aspectFill" class="swipe-image" />
      </van-swipe-item>
    </van-swipe>
    
    <!-- 功能入口 -->
    <view class="function-grid">
      <view class="function-item" @click="navigateToReservation">
        <van-icon name="calendar" class="function-icon" />
        <text class="function-text">立即预约</text>
      </view>
      <view class="function-item" @click="navigateToHistory">
        <van-icon name="clock-o" class="function-icon" />
        <text class="function-text">预约历史</text>
      </view>
      <view class="function-item" @click="navigateToFavorite">
        <van-icon name="star-o" class="function-icon" />
        <text class="function-text">我的收藏</text>
      </view>
      <view class="function-item" @click="navigateToHelp">
        <van-icon name="question-circle-o" class="function-icon" />
        <text class="function-text">帮助中心</text>
      </view>
    </view>
    
    <!-- 附近车位列表 -->
    <view class="nearby-section">
      <view class="section-header">
        <text class="section-title">附近可用车位</text>
        <text class="section-more" @click="navigateToAllSpaces">查看全部</text>
      </view>
      
      <view class="space-list">
        <space-item 
          v-for="item in nearbySpaces" 
          :key="item.id" 
          :space-info="item"
          @reserve="navigateToReservePage(item.id)"
        />
      </view>
    </view>
  </view>
</template>

<script>
import { ref, onMounted } from 'vue';
import { useRouter } from 'vue-router';
import { getNearbyParkingSpaces } from '@/api/parkingSpace';
import SpaceItem from '@/components/SpaceItem.vue';

export default {
  components: {
    SpaceItem
  },
  setup() {
    const router = useRouter();
    const searchValue = ref('');
    const banners = ref([]);
    const nearbySpaces = ref([]);
    
    onMounted(() => {
      loadBanners();
      loadNearbySpaces();
    });
    
    const loadBanners = () => {
      // 实际项目中从API获取
      banners.value = [
        { imageUrl: '/static/banners/banner1.jpg' },
        { imageUrl: '/static/banners/banner2.jpg' }
      ];
    };
    
    const loadNearbySpaces = async () => {
      try {
        // 获取当前位置坐标
        const { latitude, longitude } = await new Promise((resolve, reject) => {
          wx.getLocation({
            type: 'gcj02',
            success: resolve,
            fail: reject
          });
        });
        
        // 调用API获取附近车位
        const res = await getNearbyParkingSpaces({
          latitude,
          longitude,
          radius: 2000 // 2公里范围内
        });
        
        nearbySpaces.value = res.data.list;
      } catch (error) {
        console.error('加载附近车位失败', error);
        uni.showToast({ title: '获取车位信息失败', icon: 'error' });
      }
    };
    
    // 导航方法实现...
    
    return {
      searchValue,
      banners,
      nearbySpaces,
      onSearch,
      navigateToReservation,
      navigateToHistory,
      navigateToFavorite,
      navigateToHelp,
      navigateToAllSpaces,
      navigateToReservePage
    };
  }
};
</script>

<style scoped>
/* 样式实现... */
</style>
```

### 2.2 预约页面设计与实现

#### 2.2.1 预约页面核心代码
```vue
<template>
  <view class="reservation-page">
    <view class="space-detail-card">
      <view class="space-basic-info">
        <text class="space-code">车位编号: {{ spaceInfo.code }}</text>
        <text class="space-type">{{ spaceTypeMap[spaceInfo.type] }}</text>
      </view>
      
      <view class="space-status">
        <van-tag type="success" v-if="spaceInfo.status === 0">可预约</van-tag>
        <van-tag type="danger" v-else>不可用</van-tag>
      </view>
      
      <view class="space-facilities">
        <van-icon name="wifi" v-if="spaceInfo.hasWifi" class="facility-icon" />
        <van-icon name="flashlight" v-if="spaceInfo.hasCharging" class="facility-icon" />
        <van-icon name="car" v-if="spaceInfo.isLarge" class="facility-icon" />
      </view>
    </view>
    
    <view class="reservation-form">
      <view class="form-item">
        <text class="form-label">预约日期</text>
        <van-datetime-picker
          v-model="reservationDate"
          type="date"
          :min-date="new Date()"
          @confirm="handleDateConfirm"
        />
      </view>
      
      <view class="form-item">
        <text class="form-label">预约时段</text>
        <view class="time-selector">
          <van-time-picker
            v-model="startTime"
            type="time"
            :min-hour="6"
            :max-hour="23"
            @confirm="handleStartTimeConfirm"
          />
          <text class="time-separator">至</text>
          <van-time-picker
            v-model="endTime"
            type="time"
            :min-hour="6"
            :max-hour="23"
            @confirm="handleEndTimeConfirm"
          />
        </view>
      </view>
      
      <view class="form-item">
        <text class="form-label">预计停车时长</text>
        <text class="duration-value">{{ calculateDuration() }}小时</text>
      </view>
      
      <view class="form-item">
        <text class="form-label">费用预估</text>
        <text class="price-value">￥{{ calculatePrice() }}</text>
      </view>
    </view>
    
    <view class="reservation-actions">
      <van-button 
        type="primary" 
        class="reserve-btn"
        :disabled="!canReserve"
        @click="submitReservation"
      >
        确认预约
      </van-button>
    </view>
  </view>
</template>

<script>
// 页面逻辑实现...
</script>

<style scoped>
/* 样式实现... */
</style>
```

### 2.3 "我的"页面设计与实现

#### 2.3.1 页面结构
```vue
<template>
  <view class="profile-page">
    <view class="user-info-card">
      <view class="avatar-area">
        <image :src="userInfo.avatar || '/static/images/default-avatar.png'" class="avatar" />
      </view>
      <view class="user-info">
        <text class="user-name">{{ userInfo.nickname || '未登录' }}</text>
        <text class="user-phone">{{ userInfo.phone || '未绑定手机号' }}</text>
      </view>
      <view class="edit-btn" @click="navigateToEditProfile">
        <van-icon name="edit" />
      </view>
    </view>
    
    <view class="menu-list">
      <van-cell-group>
        <van-cell 
          icon="calendar" 
          title="我的预约" 
          is-link 
          @click="navigateToMyReservations"
        />
        <van-cell 
          icon="star-o" 
          title="我的收藏" 
          is-link 
          @click="navigateToMyFavorites"
        />
        <van-cell 
          icon="credit-card" 
          title="我的订单" 
          is-link 
          @click="navigateToMyOrders"
        />
        <van-cell 
          icon="settings" 
          title="设置" 
          is-link 
          @click="navigateToSettings"
        />
      </van-cell-group>
    </view>
    
    <view class="current-reservation" v-if="hasCurrentReservation">
      <view class="reservation-header">
        <text class="header-title">当前预约</text>
        <text class="header-status">进行中</text>
      </view>
      
      <view class="reservation-details">
        <text class="detail-item">车位编号: {{ currentReservation.spaceCode }}</text>
        <text class="detail-item">停车场: {{ currentReservation.parkingName }}</text>
        <text class="detail-item">预约时间: {{ formatReservationTime() }}</text>
      </view>
      
      <view class="reservation-actions">
        <van-button 
          type="default" 
          plain 
          class="action-btn"
          @click="navigateToReservationDetail"
        >
          查看详情
        </van-button>
        <van-button 
          type="danger" 
          plain 
          class="action-btn"
          @click="cancelCurrentReservation"
        >
          取消预约
        </van-button>
      </view>
    </view>
  </view>
</template>

<script>
// 页面逻辑实现...
</script>

<style scoped>
/* 样式实现... */
</style>
```

## 三、前后端联调（步骤3）

### 3.1 接口契约定义

#### 3.1.1 响应格式标准
```json
{
  "code": 200,
  "message": "success",
  "data": {
    // 具体业务数据
  },
  "timestamp": 1622505600000
}
```

#### 3.1.2 错误响应格式
```json
{
  "code": 500101,
  "message": "车位不存在",
  "data": null,
  "timestamp": 1622505600000,
  "requestId": "req-123456789"
}
```

#### 3.1.3 状态码定义
| 状态码范围 | 含义 | 示例 |
|------------|------|------|
| 200-299 | 成功 | 200: 成功 |
| 400-499 | 客户端错误 | 400: 参数错误<br>401: 未认证<br>403: 权限不足<br>404: 资源不存在 |
| 500-599 | 服务器错误 | 500: 服务器内部错误<br>5001xx: 业务错误<br>5002xx: 第三方服务错误 |

### 3.2 联调测试用例设计

#### 3.2.1 用户认证接口测试
| 测试场景 | 请求参数 | 预期结果 | 优先级 |
|----------|----------|----------|--------|
| 微信登录 | `{code: "有效code"}` | 返回token和用户信息 | 高 |
| 获取用户信息 | `Authorization: Bearer {token}` | 返回当前用户信息 | 高 |
| 无效token访问 | `Authorization: Bearer {invalid_token}` | 返回401错误 | 中 |

#### 3.2.2 车位查询接口测试
| 测试场景 | 请求参数 | 预期结果 | 优先级 |
|----------|----------|----------|--------|
| 查询附近车位 | `{latitude: 39.908823, longitude: 116.397470, radius: 2000}` | 返回附近2公里内车位列表 | 高 |
| 查询特定状态车位 | `{status: 0}` | 只返回空闲车位 | 中 |
| 查询不存在车位ID | `GET /api/v1/parking-spaces/9999` | 返回404错误 | 中 |

#### 3.2.3 预约接口测试
| 测试场景 | 请求参数 | 预期结果 | 优先级 |
|----------|----------|----------|--------|
| 正常预约 | `{spaceId: 1, startTime: "2023-06-01 10:00", endTime: "2023-06-01 12:00"}` | 预约成功，返回订单信息 | 高 |
| 预约已被占用车位 | `{spaceId: 1, startTime: "2023-06-01 10:00", endTime: "2023-06-01 12:00"}` | 返回车位已被占用错误 | 高 |
| 取消自己的预约 | `PUT /api/v1/reservations/1/cancel` | 预约取消成功 | 高 |
| 取消他人预约 | `PUT /api/v1/reservations/2/cancel` | 返回权限不足错误 | 中 |

### 3.3 联调问题排查指南

#### 3.3.1 常见问题及解决方案
| 问题现象 | 可能原因 | 排查步骤 | 解决方案 |
|----------|----------|----------|----------|
| 接口返回401 | 未登录或token过期 | 1. 检查请求头是否有Authorization<br>2. 检查token是否过期<br>3. 检查token格式是否正确 | 1. 重新登录获取token<br>2. 确保Authorization格式正确<br>3. 实现token自动刷新机制 |
| 接口返回400 | 参数错误 | 1. 检查请求参数是否完整<br>2. 检查参数格式是否正确<br>3. 查看返回的错误消息 | 1. 补充缺失参数<br>2. 修正参数格式<br>3. 根据错误消息调整参数 |
| 车位状态不一致 | 缓存未更新 | 1. 检查数据库中车位状态<br>2. 检查Redis缓存值<br>3. 检查缓存更新逻辑 | 1. 手动清除缓存<br>2. 修复缓存更新逻辑<br>3. 增加缓存过期时间监控 |
| 预约冲突 | 并发控制问题 | 1. 检查预约接口并发控制逻辑<br>2. 查看数据库锁使用情况<br>3. 检查事务隔离级别 | 1. 实现悲观锁或乐观锁<br>2. 调整事务隔离级别<br>3. 增加重试机制 |

#### 3.3.2 网络请求调试工具使用
```javascript
// 小程序网络请求拦截器配置
const install = (app) => {
  // 请求拦截器
  app.config.globalProperties.$http.interceptors.request.use(
    config => {
      // 添加请求日志
      console.log(`[${new Date().toISOString()}] 请求 ${config.url}`, config.data);
      // 添加token
      const token = uni.getStorageSync('token');
      if (token) {
        config.header.Authorization = `Bearer ${token}`;
      }
      return config;
    },
    error => {
      console.error('请求错误', error);
      return Promise.reject(error);
    }
  );
  
  // 响应拦截器
  app.config.globalProperties.$http.interceptors.response.use(
    response => {
      // 添加响应日志
      console.log(`[${new Date().toISOString()}] 响应 ${response.config.url}`, response.data);
      return response;
    },
    error => {
      console.error('响应错误', error);
      return Promise.reject(error);
    }
  );
};

export default { install };
```

## 四、第三方服务集成（步骤4）

### 4.1 高德地图服务集成

#### 4.1.1 开发准备
1. 在高德开放平台创建应用并获取API Key
2. 下载并集成微信小程序SDK

#### 4.1.2 SDK集成与初始化
```javascript
// 在main.js中初始化高德地图SDK
import amap from '@/utils/amap-wx.130.js';

const amapPlugin = new amap.AMapWX({
  key: 'your_amap_api_key' // 从环境变量获取
});

app.config.globalProperties.$amap = amapPlugin;
```

#### 4.1.3 核心功能实现
```javascript
// 地图工具类 - @/utils/mapUtil.js
export const mapUtil = {
  // 获取位置描述
  async getAddress(latitude, longitude) {
    return new Promise((resolve, reject) => {
      const amapPlugin = getApp().config.globalProperties.$amap;
      amapPlugin.getRegeo({
        location: `${longitude},${latitude}`,
        success: res => {
          if (res[0] && res[0].regeocodeData) {
            resolve(res[0].regeocodeData.formatted_address);
          } else {
            reject(new Error('获取地址失败'));
          }
        },
        fail: reject
      });
    });
  },
  
  // 计算两点间距离
  calculateDistance(startLat, startLng, endLat, endLng) {
    const radLat1 = this.radians(startLat);
    const radLat2 = this.radians(endLat);
    const a = radLat1 - radLat2;
    const b = this.radians(startLng) - this.radians(endLng);
    let s = 2 * Math.asin(Math.sqrt(
      Math.pow(Math.sin(a/2), 2) +
      Math.cos(radLat1) * Math.cos(radLat2) * Math.pow(Math.sin(b/2), 2)
    ));
    // 地球半径取6378.137公里
    s = s * 6378.137;
    return Math.round(s * 1000); // 转换为米并四舍五入
  },
  
  // 经纬度转弧度
  radians(d) {
    return d * Math.PI / 180.0;
  }
  
  // 其他地图相关方法...
};
```

### 4.2 支付服务集成

#### 4.2.1 微信支付集成
```java
// 支付服务实现
@Service
public class WechatPayServiceImpl implements PayService {
    @Autowired
    private WxPayConfig wxPayConfig;
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private ReservationMapper reservationMapper;
    
    @Override
    @Transactional
    public PayDTO createPayment(Long reservationId, Long userId) {
        // 1. 查询预约信息
        ReservationEntity reservation = reservationMapper.selectById(reservationId);
        validateReservation(reservation, userId);
        
        // 2. 计算支付金额
        BigDecimal amount = calculateAmount(reservation);
        
        // 3. 创建微信支付订单
        WxPayUnifiedOrderRequest request = new WxPayUnifiedOrderRequest();
        request.setOutTradeNo(reservation.getOrderNo());
        request.setBody("车位预约-" + reservation.getSpaceCode());
        request.setTotalFee(amount.multiply(new BigDecimal("100")).intValue()); // 转换为分
        request.setSpbillCreateIp(WebUtils.getClientIp());
        request.setNotifyUrl(wxPayConfig.getNotifyUrl());
        request.setTradeType("JSAPI");
        request.setOpenid(reservation.getOpenid());
        
        try {
            // 4. 调用微信支付接口
            WxPayUnifiedOrderResult result = wxPayService.createOrder(request);
            
            // 5. 生成小程序支付参数
            Map<String, String> payParams = wxPayService.createPaySign(result.getPrepayId());
            
            // 6. 返回支付参数
            PayDTO payDTO = new PayDTO();
            payDTO.setOrderNo(reservation.getOrderNo());
            payDTO.setAmount(amount);
            payDTO.setPayParams(payParams);
            
            return payDTO;
        } catch (WxPayException e) {
            log.error("创建微信支付订单失败", e);
            throw new BusinessException(ErrorEnum.PAY_CREATE_FAILED, e.getMessage());
        }
    }
    
    // 支付回调处理...
}
```

#### 4.2.2 小程序端支付调用
```javascript
// 支付工具类
export const payUtil = {
  /**
   * 调用微信支付
   * @param {Object} payParams - 支付参数
   * @returns {Promise}
   */
  async requestPayment(payParams) {
    return new Promise((resolve, reject) => {
      wx.requestPayment({
        timeStamp: payParams.timeStamp,
        nonceStr: payParams.nonceStr,
        package: payParams.package,
        signType: payParams.signType,
        paySign: payParams.paySign,
        success: (res) => {
          console.log('支付成功', res);
          resolve(res);
        },
        fail: (err) => {
          console.error('支付失败', err);
          reject(err);
        },
        complete: (res) => {
          console.log('支付完成', res);
        }
      });
    });
  }
};

// 支付页面调用
const handlePay = async () => {
  try {
    // 1. 获取支付参数
    const { data } = await api.createPayment({ reservationId: reservationId });
    
    // 2. 调用支付
    await payUtil.requestPayment(data.payParams);
    
    // 3. 支付成功处理
    uni.showToast({ title: '支付成功' });
    // 跳转到支付成功页面
    router.push({ 
      path: '/pages/reservation/success',
      query: { reservationId: reservationId }
    });
  } catch (error) {
    console.error('支付失败', error);
    if (error.errMsg !== 'requestPayment:fail cancel') {
      uni.showToast({ title: '支付失败，请重试', icon: 'error' });
    }
  }
};
```

### 4.3 语音识别服务集成

#### 4.3.1 服务端配置
```java
@Configuration
public class SpeechRecognitionConfig {
    @Value("${speech.app-id}")
    private String appId;
    
    @Value("${speech.api-key}")
    private String apiKey;
    
    @Value("${speech.secret-key}")
    private String secretKey;
    
    @Bean
    public SpeechRecognizer speechRecognizer() {
        SpeechRecognizer recognizer = SpeechRecognizer.createRecognizer(
            new SpeechConstant()
                .setEngineType(SpeechConstant.TYPE_CLOUD)
                .setDomain("iat")
                .setLanguage("zh_cn")
                .setAccent("mandarin")
                .setAppid(appId)
                .setApiKey(apiKey)
                .setSecretKey(secretKey)
        );
        return recognizer;
    }
}
```

#### 4.3.2 语音预约功能实现
```java
@Service
public class VoiceReservationServiceImpl implements VoiceReservationService {
    @Autowired
    private SpeechRecognizer speechRecognizer;
    
    @Autowired
    private NaturalLanguageProcessor nlpProcessor;
    
    @Autowired
    private ReservationService reservationService;
    
    @Override
    public VoiceReservationResult processVoiceReservation(byte[] voiceData, String openid) {
        // 1. 语音识别
        String text = speechToText(voiceData);
        
        // 2. 自然语言处理
        VoiceCommand command = nlpProcessor.parseVoiceCommand(text);
        
        // 3. 执行预约操作
        if (command.getType() == CommandType.RESERVATION) {
            ReservationCreateDTO dto = convertToReservationDTO(command);
            ReservationDTO reservation = reservationService.createReservationByVoice(dto, openid);
            
            return VoiceReservationResult.success(reservation, text);
        } else {
            return VoiceReservationResult.fail("不支持的语音命令类型", text);
        }
    }
    
    private String speechToText(byte[] voiceData) {
        // 语音识别实现...
    }
}
```

## 五、业务逻辑开发（步骤5）

### 5.1 预约锁定机制

#### 5.1.1 基于Redis的分布式锁实现
```java
@Component
public class RedisDistributedLock {
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    private static final String LOCK_PREFIX = "parking:lock:";
    private static final long DEFAULT_LOCK_EXPIRE = 30000; // 默认锁过期时间30秒
    
    /**
     * 获取分布式锁
     * @param resourceId 资源ID
     * @param requestId 请求ID
     * @param expireTime 过期时间(毫秒)
     * @return 是否获取成功
     */
    public boolean tryLock(String resourceId, String requestId, long expireTime) {
        String key = LOCK_PREFIX + resourceId;
        Boolean success = redisTemplate.opsForValue().setIfAbsent(
            key, requestId, expireTime, TimeUnit.MILLISECONDS);
        return Boolean.TRUE.equals(success);
    }
    
    /**
     * 释放分布式锁
     * @param resourceId 资源ID
     * @param requestId 请求ID
     * @return 是否释放成功
     */
    public boolean releaseLock(String resourceId, String requestId) {
        String key = LOCK_PREFIX + resourceId;
        String script = "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                       "return redis.call('del', KEYS[1]) " +
                       "else " +
                       "return 0 " +
                       "end";
        
        Long result = (Long) redisTemplate.execute(
            new DefaultRedisScript<>(script, Long.class),
            Collections.singletonList(key),
            requestId
        );
        
        return result != null && result > 0;
    }
    
    /**
     * 带重试机制的锁获取
     * @param resourceId 资源ID
     * @param retryTimes 重试次数
     * @param interval 重试间隔(毫秒)
     * @return 锁信息，包含requestId和是否成功获取
     */
    public LockInfo tryLockWithRetry(String resourceId, int retryTimes, long interval) {
        String requestId = UUID.randomUUID().toString();
        boolean locked = tryLock(resourceId, requestId, DEFAULT_LOCK_EXPIRE);
        
        int count = 0;
        while (!locked && count < retryTimes) {
            try {
                Thread.sleep(interval);
                locked = tryLock(resourceId, requestId, DEFAULT_LOCK_EXPIRE);
                count++;
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                return new LockInfo(false, null);
            }
        }
        
        return new LockInfo(locked, locked ? requestId : null);
    }
    
    @Data
    public static class LockInfo {
        private boolean success;
        private String requestId;
        
        public LockInfo(boolean success, String requestId) {
            this.success = success;
            this.requestId = requestId;
        }
    }
}
```

#### 5.1.2 预约锁定业务实现
```java
@Service
public class ReservationLockServiceImpl implements ReservationLockService {
    @Autowired
    private RedisDistributedLock distributedLock;
    
    @Autowired
    private ParkingSpaceMapper parkingSpaceMapper;
    
    @Autowired
    private ReservationMapper reservationMapper;
    
    @Autowired
    private TransactionStatusService transactionStatusService;
    
    @Override
    @Transactional
    public ReservationDTO lockParkingSpace(ReservationCreateDTO createDTO, String openid) {
        // 1. 获取车位ID
        Long spaceId = createDTO.getSpaceId();
        String resourceId = "space:" + spaceId;
        
        // 2. 获取分布式锁
        RedisDistributedLock.LockInfo lockInfo = distributedLock.tryLockWithRetry(
            resourceId, 3, 500); // 重试3次，间隔500ms
        
        if (!lockInfo.isSuccess()) {
            log.warn("获取车位锁失败，spaceId: {}", spaceId);
            throw new BusinessException(ErrorEnum.SYSTEM_BUSY_TRY_AGAIN);
        }
        
        try {
            // 3. 检查车位状态
            ParkingSpaceEntity space = parkingSpaceMapper.selectById(spaceId);
            if (space == null || space.getStatus() != SpaceStatus.FREE.getValue()) {
                throw new BusinessException(ErrorEnum.PARKING_SPACE_NOT_AVAILABLE);
            }
            
            // 4. 更新车位状态为"已锁定"
            int updateRows = parkingSpaceMapper.updateStatus(
                spaceId, SpaceStatus.LOCKED.getValue(), SpaceStatus.FREE.getValue());
            
            if (updateRows == 0) {
                throw new BusinessException(ErrorEnum.PARKING_SPACE_CONFLICT);
            }
            
            // 5. 创建预约记录
            ReservationEntity reservation = createReservationEntity(createDTO, space, openid);
            reservationMapper.insert(reservation);
            
            // 6. 记录事务状态
            transactionStatusService.recordStatus(
                reservation.getOrderNo(), TransactionStage.RESERVATION_CREATED);
            
            // 7. 返回预约信息
            return convertToDTO(reservation, space);
        } finally {
            // 8. 释放锁
            distributedLock.releaseLock(resourceId, lockInfo.getRequestId());
        }
    }
    
    // 辅助方法实现...
}
```

### 5.2 超时释放机制

#### 5.2.1 基于Redis的延迟队列实现
```java
@Component
public class DelayQueueService {
    @Autowired
    private StringRedisTemplate redisTemplate;
    
    private static final String DELAY_QUEUE_KEY = "parking:delay:queue";
    private static final String DELAY_QUEUE_SCHEDULED_KEY = "parking:delay:scheduled";
    
    /**
     * 添加延迟任务
     * @param taskType 任务类型
     * @param taskId 任务ID
     * @param delayTime 延迟时间(毫秒)
     */
    public void addDelayTask(String taskType, String taskId, long delayTime) {
        String task = taskType + ":" + taskId;
        long executeTime = System.currentTimeMillis() + delayTime;
        
        // 添加到ZSet
        redisTemplate.opsForZSet().add(DELAY_QUEUE_SCHEDULED_KEY, task, executeTime);
        log.info("添加延迟任务: {}, 执行时间: {}", task, new Date(executeTime));
    }
    
    /**
     * 拉取到期任务
     * @return 任务列表
     */
    public List<String> pullExpiredTasks() {
        long now = System.currentTimeMillis();
        
        // 查询到期任务
        Set<String> tasks = redisTemplate.opsForZSet().rangeByScore(
            DELAY_QUEUE_SCHEDULED_KEY, 0, now, 0, 100);
        
        if (tasks == null || tasks.isEmpty()) {
            return Collections.emptyList();
        }
        
        // 将任务从ZSet移动到List，用于消费者处理
        String[] taskArray = tasks.toArray(new String[0]);
        redisTemplate.opsForZSet().remove(DELAY_QUEUE_SCHEDULED_KEY, taskArray);
        
        redisTemplate.opsForList().rightPushAll(DELAY_QUEUE_KEY, taskArray);
        
        return Arrays.asList(taskArray);
    }
    
    /**
     * 获取任务进行处理
     * @return 任务
     */
    public String takeTask() {
        return redisTemplate.opsForList().leftPop(DELAY_QUEUE_KEY, 1, TimeUnit.SECONDS);
    }
}
```

#### 5.2.2 预约超时释放任务实现
```java
@Component
public class ReservationTimeoutHandler {
    @Autowired
    private DelayQueueService delayQueueService;
    
    @Autowired
    private ParkingSpaceMapper parkingSpaceMapper;
    
    @Autowired
    private ReservationMapper reservationMapper;
    
    @Autowired
    private TransactionStatusService transactionStatusService;
    
    /**
     * 初始化超时处理
     */
    @PostConstruct
    public void init() {
        // 启动消费者线程
        new Thread(this::processDelayTasks, "ReservationTimeoutWorker").start();
    }
    
    /**
     * 处理延迟任务
     */
    private void processDelayTasks() {
        while (true) {
            try {
                // 1. 拉取到期任务
                List<String> expiredTasks = delayQueueService.pullExpiredTasks();
                if (!expiredTasks.isEmpty()) {
                    log.info("处理到期任务: {}", expiredTasks.size());
                }
                
                // 2. 处理单个任务
                String task = delayQueueService.takeTask();
                if (task != null) {
                    processSingleTask(task);
                }
            } catch (Exception e) {
                log.error("处理超时任务异常", e);
                try {
                    Thread.sleep(1000);
                } catch (InterruptedException ie) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        }
    }
    
    private void processSingleTask(String task) {
        // 1. 解析任务
        String[] parts = task.split(":", 2);
        if (parts.length != 2) {
            log.error("无效任务格式: {}", task);
            return;
        }
        
        String taskType = parts[0];
        String taskId = parts[1];
        
        // 2. 根据任务类型处理
        if ("reservation".equals(taskType)) {
            processReservationTimeout(taskId);
        } else {
            log.warn("未知任务类型: {}", taskType);
        }
    }
    
    private void processReservationTimeout(String orderNo) {
        // 1. 查询预约信息
        ReservationEntity reservation = reservationMapper.selectByOrderNo(orderNo);
        if (reservation == null) {
            log.warn("预约不存在，orderNo: {}", orderNo);
            return;
        }
        
        // 2. 检查预约状态
        if (reservation.getStatus() != ReservationStatus.PENDING_PAYMENT.getValue()) {
            log.info("预约状态不是待支付，无需处理，orderNo: {}, status: {}", 
                    orderNo, reservation.getStatus());
            return;
        }
        
        // 3. 执行超时处理
        try {
            timeoutReservationProcessing(reservation);
        } catch (Exception e) {
            log.error("处理预约超时异常，orderNo: {}", orderNo, e);
        }
    }
    
    @Transactional
    public void timeoutReservationProcessing(ReservationEntity reservation) {
        // 1. 更新预约状态为"已取消"
        reservation.setStatus(ReservationStatus.CANCELLED_TIMEOUT.getValue());
        reservation.setUpdateTime(LocalDateTime.now());
        reservationMapper.updateById(reservation);
        
        // 2. 更新车位状态为"空闲"
        parkingSpaceMapper.updateStatus(
            reservation.getSpaceId(), SpaceStatus.FREE.getValue(), 
            SpaceStatus.LOCKED.getValue());
        
        // 3. 记录事务状态
        transactionStatusService.recordStatus(
            reservation.getOrderNo(), TransactionStage.RESERVATION_TIMEOUT);
        
        log.info("预约超时处理完成，orderNo: {}, spaceId: {}", 
                reservation.getOrderNo(), reservation.getSpaceId());
    }
}
```

#### 5.2.3 预约创建时添加超时任务
```java
@Service
public class ReservationServiceImpl implements ReservationService {
    @Autowired
    private ReservationLockService reservationLockService;
    
    @Autowired
    private DelayQueueService delayQueueService;
    
    @Autowired
    private ReservationConfig reservationConfig;
    
    @Override
    public ReservationDTO createReservation(ReservationCreateDTO createDTO) {
        // 1. 获取当前用户openid
        String openid = SecurityUtils.getCurrentUserOpenid();
        
        // 2. 锁定车位并创建预约
        ReservationDTO reservation = reservationLockService.lockParkingSpace(createDTO, openid);
        
        // 3. 添加超时释放任务（30分钟未支付自动取消）
        long delayTime = reservationConfig.getPaymentTimeoutMinutes() * 60 * 1000L;
        delayQueueService.addDelayTask(
            "reservation", reservation.getOrderNo(), delayTime);
        
        return reservation;
    }
    
    // 其他方法实现...
}
```

### 5.3 支付回调处理

#### 5.3.1 支付结果验证与处理
```java
@RestController
@RequestMapping("/api/v1/payment")
public class PaymentCallbackController {
    @Autowired
    private WechatPayService wechatPayService;
    
    @Autowired
    private PaymentCallbackService paymentCallbackService;
    
    @Autowired
    private LogService logService;
    
    @PostMapping("/wechat/notify")
    public String wechatPayNotify(HttpServletRequest request, HttpServletResponse response) {
        try {
            // 1. 读取回调数据
            String xmlData = StreamUtils.copyToString(
                request.getInputStream(), StandardCharsets.UTF_8);
            logService.savePaymentLog("WECHAT_PAY_NOTIFY", "接收回调", xmlData);
            
            // 2. 验证签名
            WxPayOrderNotifyResult notifyResult = wechatPayService.parseOrderNotifyResult(xmlData);
            
            // 3. 处理支付结果
            paymentCallbackService.processPaymentResult(
                notifyResult.getOutTradeNo(), 
                notifyResult.getTransactionId(),
                notifyResult.getTotalFee().divide(new BigDecimal("100")), // 转换为元
                "WECHAT");
            
            // 4. 返回成功响应
            return "<xml><return_code>SUCCESS</return_code><return_msg>OK</return_msg></xml>";
        } catch (Exception e) {
            log.error("处理支付回调异常", e);
            // 5. 返回失败响应
            return "<xml><return_code>FAIL</return_code><return_msg>" + 
                   e.getMessage() + "</return_msg></xml>";
        }
    }
}
```

#### 5.3.2 支付回调业务逻辑处理
```java
@Service
public class PaymentCallbackServiceImpl implements PaymentCallbackService {
    @Autowired
    private ReservationMapper reservationMapper;
    
    @Autowired
    private ParkingSpaceMapper parkingSpaceMapper;
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private TransactionStatusService transactionStatusService;
    
    @Autowired
    private MessageService messageService;
    
    @Override
    @Transactional
    public void processPaymentResult(String orderNo, String thirdPartyTradeNo, 
                                    BigDecimal amount, String payType) {
        // 1. 查询预约信息
        ReservationEntity reservation = reservationMapper.selectByOrderNo(orderNo);
        if (reservation == null) {
            throw new BusinessException(ErrorEnum.ORDER_NOT_FOUND);
        }
        
        // 2. 验证金额
        validateAmount(reservation, amount);
        
        // 3. 验证状态
        if (reservation.getStatus() != ReservationStatus.PENDING_PAYMENT.getValue()) {
            log.warn("订单状态异常，orderNo: {}, 当前状态: {}", 
                    orderNo, reservation.getStatus());
            return; // 幂等处理，直接返回成功
        }
        
        // 4. 更新预约状态
        reservation.setStatus(ReservationStatus.CONFIRMED.getValue());
        reservation.setPaymentTime(LocalDateTime.now());
        reservation.setThirdPartyTradeNo(thirdPartyTradeNo);
        reservation.setPayType(payType);
        reservationMapper.updateById(reservation);
        
        // 5. 更新车位状态
        parkingSpaceMapper.updateStatus(
            reservation.getSpaceId(), SpaceStatus.OCCUPIED.getValue(), 
            SpaceStatus.LOCKED.getValue());
        
        // 6. 创建订单记录
        orderService.createOrder(reservation, amount);
        
        // 7. 记录事务状态
        transactionStatusService.recordStatus(
            orderNo, TransactionStage.PAYMENT_COMPLETED);
        
        // 8. 发送通知
        messageService.sendReservationSuccessMessage(reservation);
        
        log.info("支付回调处理完成，orderNo: {}, thirdPartyTradeNo: {}", 
                orderNo, thirdPartyTradeNo);
    }
    
    // 辅助方法实现...
}
```

### 5.4 并发控制与数据一致性保障

#### 5.4.1 乐观锁实现
```java
// 车位实体类添加乐观锁字段
@Data
@TableName("parking_space")
public class ParkingSpaceEntity {
    @TableId(type = IdType.AUTO)
    private Long id;
    
    // 其他字段...
    
    @Version
    private Integer version; // 乐观锁版本号
}

// 乐观锁更新方法
@Mapper
public interface ParkingSpaceMapper {
    @Update("UPDATE parking_space SET status = #{newStatus}, version = version + 1, " +
           "update_time = NOW() WHERE id = #{id} AND status = #{oldStatus} AND version = #{version}")
    int updateStatusWithVersion(@Param("id") Long id, @Param("newStatus") Integer newStatus,
                               @Param("oldStatus") Integer oldStatus, @Param("version") Integer version);
}

// 服务层使用
@Service
public class ParkingSpaceServiceImpl implements ParkingSpaceService {
    @Override
    public boolean updateSpaceStatusWithOptimisticLock(Long id, Integer newStatus, 
                                                     Integer oldStatus, Integer version) {
        int rows = parkingSpaceMapper.updateStatusWithVersion(id, newStatus, oldStatus, version);
        return rows > 0;
    }
}
```

#### 5.4.2 事务隔离级别配置
```java
@Configuration
public class TransactionConfig {
    @Bean
    public PlatformTransactionManager transactionManager(DataSource dataSource) {
        DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(dataSource);
        // 设置默认事务隔离级别为READ COMMITTED
        transactionManager.setDefaultTransactionIsolationLevel(
            TransactionDefinition.ISOLATION_READ_COMMITTED);
        return transactionManager;
    }
    
    // 针对关键业务设置更高的隔离级别
    @Bean
    public TransactionTemplate reservationTransactionTemplate(PlatformTransactionManager transactionManager) {
        TransactionTemplate template = new TransactionTemplate(transactionManager);
        template.setIsolationLevel(TransactionDefinition.ISOLATION_REPEATABLE_READ);
        template.setTimeout(30); // 30秒超时
        return template;
    }
}

// 使用事务模板
@Service
public class CriticalReservationServiceImpl implements CriticalReservationService {
    @Autowired
    private TransactionTemplate reservationTransactionTemplate;
    
    @Autowired
    private ReservationLockService reservationLockService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Override
    public ReservationDTO processCriticalReservation(ReservationCreateDTO createDTO, String openid) {
        return reservationTransactionTemplate.execute(status -> {
            try {
                // 1. 检查库存
                boolean hasInventory = inventoryService.checkAndReserveInventory(
                    createDTO.getSpaceId(), createDTO.getStartTime(), createDTO.getEndTime());
                
                if (!hasInventory) {
                    status.setRollbackOnly();
                    throw new BusinessException(ErrorEnum.INVENTORY_INSUFFICIENT);
                }
                
                // 2. 创建预约
                ReservationDTO reservation = reservationLockService.lockParkingSpace(
                    createDTO, openid);
                
                return reservation;
            } catch (BusinessException e) {
                status.setRollbackOnly();
                throw e;
            } catch (Exception e) {
                status.setRollbackOnly();
                throw new BusinessException(ErrorEnum.SYSTEM_ERROR);
            }
        });
    }
}
```