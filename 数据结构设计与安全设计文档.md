# 智能停车场系统 - 数据结构设计与安全设计文档

## 1. 数据结构设计

### 1.1 E-R 图

**实体-关系图描述：**

智能停车场系统包含以下主要实体及其关系：

1. **用户(User)**
   - 主键: 用户ID (user_id)
   - 属性: 用户名、密码、手机号、车牌号、微信OpenID等
   - 关系: 一个用户可以进行多个预约 (一对多)

2. **停车场(ParkingLot)**
   - 主键: 停车场ID (parking_lot_id)
   - 属性: 停车场名称、地址、总车位数、可用车位数、经纬度、收费标准、状态等
   - 关系: 一个停车场拥有多个停车位 (一对多)

3. **停车位(ParkingSpace)**
   - 主键: 车位ID (space_id)
   - 属性: 车位编号、所属停车场ID、经纬度、状态、车位类型等
   - 关系: 一个停车位可以被多次预约 (一对多)

4. **预约(Reservation)**
   - 主键: 预约ID (reservation_id)
   - 属性: 用户ID、车位ID、预约时间、开始时间、结束时间、状态、支付状态等
   - 关系: 一个预约关联一个用户和一个停车位 (多对一)

```
+------------+        +---------------+        +---------------+
|            |        |               |        |               |
|   User     |1      M|ParkingLot     |1      M|ParkingSpace   |
|            |+------>|               |+------>|               |
| user_id    |        | parking_lot_id|        | space_id      |
| username   |        | name          |        | space_number  |
| password   |        | address       |        | parking_lot_id|
| phone      |        | total_spaces  |        | status        |
| license_plate|      | available_spaces|      | space_type    |
| openid     |        | longitude     |        | longitude     |
+------------+        | latitude      |        | latitude      |
     |                +---------------+        +---------------+
     |                                               |
     |                                               |
     |M                                              1
     |                                               |
     |                                               |
+----------------------------------------------------+
|                                                    |
|                    Reservation                     |
|                                                    |
| reservation_id                                     |
| user_id                                            |
| space_id                                           |
| reserve_time                                       |
| start_time                                         |
| end_time                                           |
| status                                             |
| payment_status                                     |
+----------------------------------------------------+
```

### 1.2 数据库逻辑设计

根据E-R图，将实体关系转换为关系模式如下：

#### 1.2.1 用户表 (user)
```
user (user_id, username, password_hash, phone_number, license_plate, openid, created_at, updated_at)
```

**主键**: user_id

#### 1.2.2 停车场表 (parking_lot)
```
parking_lot (parking_lot_id, name, address, total_spaces, available_spaces, hourly_rate, longitude, latitude, status, created_at, updated_at)
```

**主键**: parking_lot_id

#### 1.2.3 停车位表 (parking_space)
```
parking_space (space_id, parking_lot_id, space_number, space_type, longitude, latitude, status, created_at, updated_at)
```

**主键**: space_id
**外键**: parking_lot_id (引用 parking_lot.parking_lot_id)

#### 1.2.4 预约表 (reservation)
```
reservation (reservation_id, user_id, space_id, license_plate, reserve_time, start_time, end_time, status, payment_status, created_at, updated_at)
```

**主键**: reservation_id
**外键**: 
- user_id (引用 user.user_id)
- space_id (引用 parking_space.space_id)

### 1.3 数据库物理设计

#### 1.3.1 用户表 (user)

```sql
CREATE TABLE IF NOT EXISTS user (
    user_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
    username VARCHAR(50) UNIQUE NOT NULL COMMENT '用户名',
    password_hash VARCHAR(100) NOT NULL COMMENT '密码哈希值',
    phone_number VARCHAR(20) UNIQUE NOT NULL COMMENT '手机号',
    license_plate VARCHAR(20) COMMENT '车牌号',
    openid VARCHAR(50) UNIQUE COMMENT '微信OpenID',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_phone_number (phone_number),
    INDEX idx_openid (openid)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户信息表';
```

#### 1.3.2 停车场表 (parking_lot)

```sql
CREATE TABLE IF NOT EXISTS parking_lot (
    parking_lot_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '停车场ID',
    name VARCHAR(100) NOT NULL COMMENT '停车场名称',
    address VARCHAR(255) NOT NULL COMMENT '停车场地址',
    total_spaces INT NOT NULL DEFAULT 0 COMMENT '总车位数',
    available_spaces INT NOT NULL DEFAULT 0 COMMENT '可用车位数',
    hourly_rate DECIMAL(10,2) NOT NULL DEFAULT 5.00 COMMENT '每小时收费',
    longitude DECIMAL(10,7) NOT NULL COMMENT '经度',
    latitude DECIMAL(10,7) NOT NULL COMMENT '纬度',
    status VARCHAR(20) NOT NULL DEFAULT 'open' COMMENT '状态：open/closed',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_location (longitude, latitude),
    INDEX idx_status (status)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='停车场信息表';
```

#### 1.3.3 停车位表 (parking_space)

```sql
CREATE TABLE IF NOT EXISTS parking_space (
    space_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '车位ID',
    parking_lot_id INT NOT NULL COMMENT '所属停车场ID',
    space_number VARCHAR(20) NOT NULL COMMENT '车位编号',
    space_type VARCHAR(20) NOT NULL DEFAULT 'normal' COMMENT '车位类型：normal/handicapped/charging',
    longitude DECIMAL(10,7) NOT NULL COMMENT '经度',
    latitude DECIMAL(10,7) NOT NULL COMMENT '纬度',
    status VARCHAR(20) NOT NULL DEFAULT 'available' COMMENT '状态：available/occupied/reserved',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_parking_lot_id (parking_lot_id),
    INDEX idx_status (status),
    UNIQUE KEY uk_space_number (parking_lot_id, space_number),
    FOREIGN KEY (parking_lot_id) REFERENCES parking_lot(parking_lot_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='停车位信息表';
```

#### 1.3.4 预约表 (reservation)

```sql
CREATE TABLE IF NOT EXISTS reservation (
    reservation_id INT PRIMARY KEY AUTO_INCREMENT COMMENT '预约ID',
    user_id INT NOT NULL COMMENT '用户ID',
    space_id INT NOT NULL COMMENT '车位ID',
    license_plate VARCHAR(20) NOT NULL COMMENT '车牌号',
    reserve_time DATETIME NOT NULL COMMENT '预约时间',
    start_time DATETIME NOT NULL COMMENT '预约开始时间',
    end_time DATETIME NOT NULL COMMENT '预约结束时间',
    status VARCHAR(20) NOT NULL DEFAULT 'pending' COMMENT '状态：pending/confirmed/cancelled/expired/completed',
    payment_status VARCHAR(20) NOT NULL DEFAULT 'unpaid' COMMENT '支付状态：unpaid/paid/refunded',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX idx_user_id (user_id),
    INDEX idx_space_id (space_id),
    INDEX idx_status (status),
    INDEX idx_reserve_time (reserve_time),
    FOREIGN KEY (user_id) REFERENCES user(user_id) ON DELETE CASCADE,
    FOREIGN KEY (space_id) REFERENCES parking_space(space_id) ON DELETE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='预约记录表';
```

#### 1.3.5 索引优化

- **位置索引**: 为停车场和停车位的经纬度创建复合索引，优化位置查询
- **状态索引**: 为停车位状态和预约状态创建索引，优化状态筛选
- **关联索引**: 为外键列创建索引，优化表连接操作
- **唯一索引**: 确保停车场内车位编号唯一，避免数据重复

#### 1.3.6 视图设计

**停车场可用性视图**:
```sql
CREATE VIEW v_parking_lot_availability AS
SELECT 
    pl.parking_lot_id,
    pl.name,
    pl.address,
    pl.total_spaces,
    pl.available_spaces,
    pl.longitude,
    pl.latitude,
    pl.status,
    (pl.available_spaces / pl.total_spaces) * 100 AS occupancy_rate
FROM 
    parking_lot pl;
```

**用户预约历史视图**:
```sql
CREATE VIEW v_user_reservation_history AS
SELECT 
    r.reservation_id,
    u.username,
    u.license_plate,
    ps.space_number,
    pl.name AS parking_lot_name,
    r.start_time,
    r.end_time,
    r.status,
    r.payment_status,
    r.created_at
FROM 
    reservation r
JOIN 
    user u ON r.user_id = u.user_id
JOIN 
    parking_space ps ON r.space_id = ps.space_id
JOIN 
    parking_lot pl ON ps.parking_lot_id = pl.parking_lot_id;
```

## 2. 出错处理与安全设计

### 2.1 业务异常处理

#### 2.1.1 预约冲突处理

```javascript
/**
 * 检查预约时间是否与现有预约冲突
 * @param {number} spaceId - 停车位ID
 * @param {Date} startTime - 预约开始时间
 * @param {Date} endTime - 预约结束时间
 * @returns {boolean} - 是否存在冲突
 */
function checkReservationConflict(spaceId, startTime, endTime) {
  return new Promise((resolve, reject) => {
    const sql = `
      SELECT * FROM reservation 
      WHERE space_id = ? 
      AND status IN ('pending', 'confirmed') 
      AND ((start_time < ? AND end_time > ?) OR 
           (start_time >= ? AND start_time < ?) OR 
           (end_time > ? AND end_time <= ?))
    `;
    
    db.query(sql, [spaceId, endTime, startTime, startTime, endTime, startTime, endTime], (error, results) => {
      if (error) {
        console.error('检查预约冲突时出错:', error);
        reject(new Error('预约冲突检查失败，请稍后重试'));
        return;
      }
      
      resolve(results.length > 0);
    });
  });
}
```

#### 2.1.2 车位状态一致性保证

```javascript
/**
 * 创建预约并更新车位状态
 * @param {Object} reservationData - 预约数据
 * @returns {Promise} - 预约结果
 */
async function createReservation(reservationData) {
  // 开始事务
  return new Promise((resolve, reject) => {
    db.beginTransaction(error => {
      if (error) {
        console.error('开始事务失败:', error);
        reject(new Error('系统繁忙，请稍后重试'));
        return;
      }
      
      // 检查车位状态
      const checkSpaceSql = 'SELECT status FROM parking_space WHERE space_id = ? FOR UPDATE';
      db.query(checkSpaceSql, [reservationData.spaceId], (error, spaceResults) => {
        if (error || spaceResults.length === 0) {
          db.rollback();
          reject(error ? new Error('查询车位信息失败') : new Error('车位不存在'));
          return;
        }
        
        if (spaceResults[0].status !== 'available') {
          db.rollback();
          reject(new Error('该车位当前不可预约'));
          return;
        }
        
        // 创建预约记录
        const insertReservationSql = `
          INSERT INTO reservation (user_id, space_id, license_plate, reserve_time, start_time, end_time)
          VALUES (?, ?, ?, NOW(), ?, ?)
        `;
        
        db.query(insertReservationSql, [
          reservationData.userId,
          reservationData.spaceId,
          reservationData.licensePlate,
          reservationData.startTime,
          reservationData.endTime
        ], (error, reservationResults) => {
          if (error) {
            db.rollback();
            reject(new Error('创建预约失败，请稍后重试'));
            return;
          }
          
          // 更新车位状态
          const updateSpaceSql = 'UPDATE parking_space SET status = ? WHERE space_id = ?';
          db.query(updateSpaceSql, ['reserved', reservationData.spaceId], (error) => {
            if (error) {
              db.rollback();
              reject(new Error('更新车位状态失败'));
              return;
            }
            
            // 更新停车场可用车位数量
            const updateParkingLotSql = `
              UPDATE parking_lot pl
              JOIN parking_space ps ON pl.parking_lot_id = ps.parking_lot_id
              SET pl.available_spaces = pl.available_spaces - 1
              WHERE ps.space_id = ?
            `;
            
            db.query(updateParkingLotSql, [reservationData.spaceId], (error) => {
              if (error) {
                db.rollback();
                reject(new Error('更新停车场信息失败'));
                return;
              }
              
              // 提交事务
              db.commit(error => {
                if (error) {
                  db.rollback();
                  reject(new Error('系统繁忙，请稍后重试'));
                  return;
                }
                
                resolve({ reservationId: reservationResults.insertId });
              });
            });
          });
        });
      });
    });
  });
}
```

### 2.2 接口异常处理

#### 2.2.1 全局错误处理器

```javascript
/**
 * 全局错误处理中间件
 */
app.use((err, req, res, next) => {
  // 记录错误日志
  console.error('请求错误:', {
    path: req.path,
    method: req.method,
    params: req.params,
    query: req.query,
    body: sanitizeLogData(req.body), // 脱敏敏感数据
    error: err.message,
    stack: err.stack
  });
  
  // 判断错误类型
  if (err.name === 'ValidationError') {
    return res.status(400).json({
      code: 'VALIDATION_ERROR',
      message: '请求参数错误',
      details: err.details.map(detail => detail.message)
    });
  }
  
  if (err.code === 'ER_DUP_ENTRY') {
    return res.status(409).json({
      code: 'DUPLICATE_ENTRY',
      message: '该数据已存在'
    });
  }
  
  // 自定义业务错误
  if (err.statusCode) {
    return res.status(err.statusCode).json({
      code: err.code || 'BUSINESS_ERROR',
      message: err.message
    });
  }
  
  // 未预期的错误
  res.status(500).json({
    code: 'INTERNAL_ERROR',
    message: '系统内部错误，请稍后重试'
  });
});
```

#### 2.2.2 请求参数验证

```javascript
/**
 * 验证预约请求参数
 * @param {Object} req - Express请求对象
 * @param {Object} res - Express响应对象
 * @param {Function} next - 下一个中间件
 */
function validateReservationRequest(req, res, next) {
  const { spaceId, startTime, endTime, licensePlate } = req.body;
  const errors = [];
  
  if (!spaceId || typeof spaceId !== 'number' || spaceId <= 0) {
    errors.push('无效的车位ID');
  }
  
  const start = new Date(startTime);
  const end = new Date(endTime);
  const now = new Date();
  
  if (isNaN(start.getTime()) || isNaN(end.getTime())) {
    errors.push('无效的时间格式');
  } else if (start < now) {
    errors.push('预约开始时间不能早于当前时间');
  } else if (end <= start) {
    errors.push('预约结束时间必须晚于开始时间');
  } else if (end - start > 24 * 60 * 60 * 1000) { // 超过24小时
    errors.push('单次预约时长不能超过24小时');
  }
  
  if (!licensePlate || !/^[京津沪渝冀豫云辽黑湘皖鲁新苏浙赣鄂桂甘晋蒙陕吉闽贵粤青藏川宁琼使领A-Z]{1}[A-Z]{1}[A-Z0-9]{4}[A-Z0-9挂学警港澳]{1}$/.test(licensePlate)) {
    errors.push('车牌号格式不正确');
  }
  
  if (errors.length > 0) {
    return res.status(400).json({
      code: 'VALIDATION_ERROR',
      message: '参数验证失败',
      details: errors
    });
  }
  
  next();
}
```

### 2.3 数据安全设计

#### 2.3.1 密码加密存储

```javascript
const bcrypt = require('bcrypt');
const SALT_ROUNDS = 12;

/**
 * 加密用户密码
 * @param {string} password - 原始密码
 * @returns {Promise<string>} - 加密后的密码哈希值
 */
async function hashPassword(password) {
  try {
    return await bcrypt.hash(password, SALT_ROUNDS);
  } catch (error) {
    console.error('密码加密失败:', error);
    throw new Error('系统内部错误');
  }
}

/**
 * 验证密码
 * @param {string} password - 原始密码
 * @param {string} hash - 数据库中的密码哈希值
 * @returns {Promise<boolean>} - 密码是否匹配
 */
async function verifyPassword(password, hash) {
  try {
    return await bcrypt.compare(password, hash);
  } catch (error) {
    console.error('密码验证失败:', error);
    throw new Error('认证失败');
  }
}
```

#### 2.3.2 SQL注入防护

```javascript
/**
 * 安全的数据库查询示例
 */
function getNearbyParkingLots(longitude, latitude, radius) {
  // 使用参数化查询防止SQL注入
  const sql = `
    SELECT 
      *, 
      (6371 * acos(
        cos(radians(?)) * cos(radians(latitude)) * 
        cos(radians(longitude) - radians(?)) + 
        sin(radians(?)) * sin(radians(latitude))
      )) AS distance 
    FROM 
      parking_lot 
    WHERE 
      status = 'open' 
    HAVING 
      distance < ? 
    ORDER BY 
      distance 
    LIMIT 20
  `;
  
  return new Promise((resolve, reject) => {
    db.query(sql, [latitude, longitude, latitude, radius], (error, results) => {
      if (error) {
        console.error('查询附近停车场失败:', error);
        reject(new Error('查询失败，请稍后重试'));
        return;
      }
      resolve(results);
    });
  });
}
```

#### 2.3.3 数据脱敏处理

```javascript
/**
 * 脱敏敏感数据
 * @param {Object} data - 需要脱敏的数据
 * @returns {Object} - 脱敏后的数据
 */
function sanitizeLogData(data) {
  if (!data || typeof data !== 'object') return data;
  
  const sanitized = { ...data };
  
  // 脱敏手机号
  if (sanitized.phoneNumber || sanitized.phone || sanitized.tel) {
    const phoneField = sanitized.phoneNumber ? 'phoneNumber' : 
                       sanitized.phone ? 'phone' : 'tel';
    sanitized[phoneField] = maskPhone(sanitized[phoneField]);
  }
  
  // 脱敏密码相关字段
  if (sanitized.password) sanitized.password = '******';
  if (sanitized.confirmPassword) sanitized.confirmPassword = '******';
  if (sanitized.newPassword) sanitized.newPassword = '******';
  
  // 脱敏身份证号
  if (sanitized.idCard || sanitized.idNumber) {
    const idField = sanitized.idCard ? 'idCard' : 'idNumber';
    sanitized[idField] = maskIdCard(sanitized[idField]);
  }
  
  return sanitized;
}

/**
 * 手机号脱敏
 * @param {string} phone - 手机号
 * @returns {string} - 脱敏后的手机号
 */
function maskPhone(phone) {
  if (!phone || typeof phone !== 'string' || phone.length < 11) return phone;
  return phone.replace(/(\d{3})\d{4}(\d{4})/, '$1****$2');
}

/**
 * 身份证号脱敏
 * @param {string} idCard - 身份证号
 * @returns {string} - 脱敏后的身份证号
 */
function maskIdCard(idCard) {
  if (!idCard || typeof idCard !== 'string' || idCard.length < 15) return idCard;
  return idCard.replace(/(\d{6})\d{8,10}(\d{4})/, '$1********$2');
}
```

### 2.4 性能异常处理

#### 2.4.1 数据库查询超时处理

```javascript
/**
 * 设置数据库查询超时
 * @param {number} timeoutMs - 超时时间（毫秒）
 * @returns {Object} - 超时配置
 */
function withQueryTimeout(timeoutMs = 5000) {
  return {
    timeout: timeoutMs,
    beforeQuery: (params) => {
      console.time(`Query: ${params.sql.substring(0, 50)}...`);
      return params;
    },
    afterQuery: (params, result) => {
      console.timeEnd(`Query: ${params.sql.substring(0, 50)}...`);
      return result;
    }
  };
}

/**
 * 查询超时错误处理示例
 */
async function getUserParkingHistory(userId, page = 1, pageSize = 10) {
  try {
    const offset = (page - 1) * pageSize;
    const sql = `
      SELECT r.*, ps.space_number, pl.name as parking_lot_name 
      FROM reservation r
      JOIN parking_space ps ON r.space_id = ps.space_id
      JOIN parking_lot pl ON ps.parking_lot_id = pl.parking_lot_id
      WHERE r.user_id = ?
      ORDER BY r.created_at DESC
      LIMIT ? OFFSET ?
    `;
    
    // 使用超时配置
    const [rows] = await db.query(sql, [userId, pageSize, offset], withQueryTimeout(3000));
    
    // 获取总数
    const [totalRows] = await db.query(
      'SELECT COUNT(*) as count FROM reservation WHERE user_id = ?',
      [userId],
      withQueryTimeout(2000)
    );
    
    return {
      data: rows,
      pagination: {
        total: totalRows[0].count,
        page,
        pageSize,
        pages: Math.ceil(totalRows[0].count / pageSize)
      }
    };
  } catch (error) {
    if (error.code === 'ER_QUERY_TIMEOUT') {
      console.error('查询超时:', error);
      throw new Error('查询数据耗时过长，请稍后重试');
    }
    throw error;
  }
}
```

#### 2.4.2 接口限流保护

```javascript
const rateLimit = require('express-rate-limit');
const RedisStore = require('rate-limit-redis');

// API限流配置
const apiLimiter = rateLimit({
  store: new RedisStore({}), // 使用Redis存储
  windowMs: 15 * 60 * 1000, // 15分钟窗口
  max: 100, // 每IP限制100次请求
  message: {
    code: 'RATE_LIMIT_EXCEEDED',
    message: '请求过于频繁，请稍后再试'
  },
  headers: true, // 包含限流信息在响应头
  keyGenerator: (req) => req.ip, // 基于IP地址限流
  onLimitReached: (req, res, options) => {
    console.warn('API限流触发:', {
      ip: req.ip,
      path: req.path,
      method: req.method,
      headers: req.headers['user-agent']
    });
  }
});

// 登录接口更严格的限流
const loginLimiter = rateLimit({
  store: new RedisStore({}),
  windowMs: 60 * 60 * 1000, // 1小时窗口
  max: 5, // 每IP限制5次登录尝试
  message: {
    code: 'LOGIN_ATTEMPTS_EXCEEDED',
    message: '登录尝试次数过多，请1小时后再试'
  },
  onLimitReached: (req, res, options) => {
    console.error('登录限流触发，可能存在暴力破解:', {
      ip: req.ip,
      username: req.body.username || 'unknown',
      headers: req.headers['user-agent']
    });
  }
});

// 应用限流中间件
app.use('/api/', apiLimiter);
app.use('/api/login', loginLimiter);
```

### 2.5 自动恢复机制

#### 2.5.1 定时任务修复数据一致性

```javascript
const cron = require('node-cron');

// 定时任务：清理过期预约并更新车位状态
cron.schedule('*/10 * * * *', async () => {
  console.log('开始执行定时任务：清理过期预约');
  
  try {
    const now = new Date();
    
    // 查找所有过期且未取消的预约
    const expiredReservations = await db.query(
      'SELECT id, space_id FROM reservation WHERE status = ? AND end_time < ?',
      ['pending', now]
    );
    
    if (expiredReservations.length === 0) {
      console.log('没有需要清理的过期预约');
      return;
    }
    
    // 开始事务
    await db.beginTransaction();
    
    // 更新过期预约状态
    const spaceIds = expiredReservations.map(res => res.space_id);
    
    await db.query(
      'UPDATE reservation SET status = ? WHERE id IN (?)',
      ['expired', expiredReservations.map(res => res.id)]
    );
    
    // 更新对应车位状态为可用
    await db.query(
      'UPDATE parking_space SET status = ? WHERE space_id IN (?)',
      ['available', spaceIds]
    );
    
    // 更新停车场可用车位数
    for (const spaceId of spaceIds) {
      await db.query(`
        UPDATE parking_lot pl
        JOIN parking_space ps ON pl.parking_lot_id = ps.parking_lot_id
        SET pl.available_spaces = pl.available_spaces + 1
        WHERE ps.space_id = ?
      `, [spaceId]);
    }
    
    // 提交事务
    await db.commit();
    
    console.log(`成功清理了${expiredReservations.length}个过期预约`);
  } catch (error) {
    // 回滚事务
    await db.rollback();
    console.error('清理过期预约失败:', error);
    
    // 发送警报通知
    sendAlertNotification('清理过期预约任务失败', error);
  }
});

/**
 * 发送警报通知
 * @param {string} title - 警报标题
 * @param {Error} error - 错误对象
 */
function sendAlertNotification(title, error) {
  // 这里可以实现邮件通知、短信通知或企业微信通知等
  console.error(`[警报] ${title}:`, error);
}
```

### 2.6 可追溯性设计

#### 2.6.1 操作日志记录

```javascript
/**
 * 记录关键操作日志
 * @param {string} userId - 用户ID
 * @param {string} action - 操作类型
 * @param {Object} details - 操作详情
 * @param {boolean} success - 是否成功
 */
function logOperation(userId, action, details, success = true) {
  const logEntry = {
    user_id: userId,
    action,
    details: sanitizeLogData(details), // 脱敏处理
    success,
    timestamp: new Date(),
    ip: details.ip || 'unknown',
    user_agent: details.userAgent || 'unknown'
  };
  
  // 写入日志表
  db.query(
    'INSERT INTO operation_log (user_id, action, details, success, ip, user_agent) VALUES (?, ?, ?, ?, ?, ?)',
    [logEntry.user_id, logEntry.action, JSON.stringify(logEntry.details), logEntry.success, logEntry.ip, logEntry.user_agent],
    (error) => {
      if (error) {
        console.error('写入操作日志失败:', error);
      }
    }
  );
  
  // 同时输出到控制台，便于实时监控
  if (!success) {
    console.warn(`[操作日志] ${userId} 执行 ${action} 失败:`, logEntry.details);
  } else {
    console.log(`[操作日志] ${userId} 执行 ${action} 成功`);
  }
}
```

#### 2.6.2 数据变更日志

```javascript
/**
 * 记录数据变更日志
 * @param {string} tableName - 表名
 * @param {number} recordId - 记录ID
 * @param {string} operation - 操作类型 (insert/update/delete)
 * @param {Object} oldData - 变更前数据
 * @param {Object} newData - 变更后数据
 * @param {string} operator - 操作者ID
 */
function logDataChange(tableName, recordId, operation, oldData, newData, operator) {
  // 脱敏敏感字段
  const sanitizedOldData = sanitizeLogData(oldData);
  const sanitizedNewData = sanitizeLogData(newData);
  
  const changeLog = {
    table_name: tableName,
    record_id: recordId,
    operation,
    old_data: operation !== 'insert' ? JSON.stringify(sanitizedOldData) : null,
    new_data: operation !== 'delete' ? JSON.stringify(sanitizedNewData) : null,
    operator,
    changed_at: new Date()
  };
  
  // 写入变更日志表
  db.query(
    `INSERT INTO data_change_log 
     (table_name, record_id, operation, old_data, new_data, operator, changed_at) 
     VALUES (?, ?, ?, ?, ?, ?, ?)`,
    [
      changeLog.table_name,
      changeLog.record_id,
      changeLog.operation,
      changeLog.old_data,
      changeLog.new_data,
      changeLog.operator,
      changeLog.changed_at
    ],
    (error) => {
      if (error) {
        console.error('写入数据变更日志失败:', error);
      }
    }
  );
}
```

## 3. 结论

本文档详细设计了智能停车场系统的数据结构和安全机制，包括：

1. **数据结构设计**：通过E-R图清晰展示了系统中的实体关系，将其转换为关系模式，并详细定义了数据库物理结构，包括表结构、索引和视图设计，为系统提供了坚实的数据基础。

2. **安全设计**：遵循"及时感知、明确反馈、自动恢复、可追溯"原则，设计了完整的异常处理和安全保障机制：
   - **业务异常处理**：处理预约冲突、保证车位状态一致性
   - **接口异常处理**：全局错误处理、请求参数验证
   - **数据安全设计**：密码加密、SQL注入防护、数据脱敏
   - **性能异常处理**：查询超时处理、接口限流保护
   - **自动恢复机制**：定时任务修复数据一致性
   - **可追溯性设计**：操作日志和数据变更日志记录

这些设计确保了系统在面对各种异常情况时能够稳定运行，同时保护用户数据安全，提高系统的可用性和可靠性。